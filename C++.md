# C++





## protected

private就是只能在该类中访问，protected就是在private的基础上再加两个：子类函数中直接访问，子类函数中使用子类对象访问

age是父类中的protected变量，子类采用public继承

子类函数可以直接return age，或者函数里面通过**子类对象**.age，但是**不能通过父类对象.age**



## memset()

函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。



## 枚举

如果一个变量需要几种可能存在的值，那么就可以被定义为枚举类型。之所以叫枚举，就是说将变量（对象）可能存在的情况（也可以说是可能的值）一一列举出来。

**枚举在c++中，是一个被命名的整型常数集合**，第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。

```c++
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

```c++
enum season {spring, summer=3, autumn, winter};
```

*没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5*



对于枚举变量中的枚举元素，系统按照**常量**来处理，叫做枚举常量。以下写法错误

```c++
pencil = 1;
```



同一枚举变量中的枚举子不需要唯一，这主要用于分类

```c++
enum some_big_cites{
  Guangzhou = 1,
  Shenzhen = 1,
  Hongkong = 1,
  Shanghai = 2,
  Beijing = 3,
  Tianjin = 3,
};
```

五个城市按照华南（1），华东（2），华北（3）进行了分类。





### 枚举变量的定义

1. **先定义枚举类型，再定义枚举变量**

   ```c++
   enum DAY
   {
         MON=1, TUE, WED, THU, FRI, SAT, SUN
   };
   enum DAY day;
   ```

2. **定义枚举类型的同时定义枚举变量**

   ```c++
   enum DAY
   {
         MON=1, TUE, WED, THU, FRI, SAT, SUN
   } day;
   ```

3. **省略枚举名称，直接定义枚举变量**

   ```c++
   enum DAY
   {
         MON=1, TUE, WED, THU, FRI, SAT, SUN
   } day;
   ```



## 左值与右值

左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式).

在 c 语言中，通常来说有名字的变量就是左值(如上面例子中的 a, b)，而由运算操作(加减乘除，函数调用返回值等)所产生的中间结果(没有名字)就是右值，如上的 3 + 4， a + b 等。我们暂且可以认为：左值就是在程序中能够寻值的东西，右值就是没法取到它的地址的东西(不完全准确)，但如上概念到了 c++ 中，就变得稍有不同。具体来说，在 c++ 中，每一个表达式都会产生一个左值，或者右值，相应的，该表达式也就被称作“左值表达式"， "右值表达式"。对于基本数据类型来说(primitive types)，左值右值的概念和 c 没有太多不同，不同的地方在于自定义的类型，而且这种不同比较容易让人混淆:

1) 对于基础类型，右值是不可被修改的(non-modifiable)，也不可被 const, volatile 所修饰(cv-qualitification ignored)

2) 对于自定义的类型(user-defined types)，右值却允许通过它的成员函数进行修改。

对于 1)，这和 c 是一致的，2) 却是 C++ 中所独有, 因此，如果你看到 C++ 中如下的写法，千万不要惊讶：

### 枚举类型的作用域

注意，枚举类型的作用域属于定义枚举的作用域，而不属于这个枚举类型。

以下代码报错：pencil重定义

```c++
	enum{
		pencil,pen
	}box1;
	enum{
		pencil,pen
	}box2;
```





## cout,cin

```c++
char s[20] = "shenchen007";
cout << s << endl;//可以直接输出字符数组
 
cout.put();//一次输出一个字符
cout.write(s,4);//输出字符数组s中的前4个字符   不能是字符串
```



![image-20211105173600642](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211105173600642.png)

## ![image-20211105173912290](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211105173912290.png)





## 表达式的值为其左值的值



## 浮点数的科学计数法

E （e）前面必须有数字，后面也必须有数字，且后面必须为整数（e前后都可以带符号）





## 数组

数组的空间在编译阶段分配，所以表示数组大小的不能为变量



### 一维数组与指针

![image-20211107114208693](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107114208693.png)



### 二维数组

![image-20211107112635717](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107112635717.png)

![image-20211107112614280](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107112614280.png)







## 数组名

数组名是常量地址，不能作为左值





## 函数返回 值与指针 的问题

一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。

1. 可以返回指向字符串常量的局部指针

   ```c++
       #include <stdio.h>   
       char *returnStr()   
       {   
           char *p="hello world!";   
           return p;   
       }   
       int main()   
       {   
           char *str;   
           str=returnStr();   
           printf("%s\n", str);   
           return 0;   
       } 
   ```

   这个没有任何问题，因为"hello world!"是一个字符串常量，存放在***\*只读数据段(全局变量数据区)\****，把该字符串常量存放的只读数据段的首地址赋值给了指针，所以returnStr函数退出时，该该字符串常量所在内存不会被回收，故能够通过指针顺利无误的访问。

   devc中不会报错，但是会给出警告，给局部变量加上static之后就没有了警告。

2. ​	可以返回局部变量的**值**，可以返回局部静态变量的**指针**或**地址**

   ```c++
   
       int func()  
       {  
             int a;  
             ....  
             return a;    //允许  
       }                     
         
       int * func()  
       {  
             int a;  
             ....  
             return &a;    //无意义，不应该这样做  
       }  
   ```

   局部变量也分局部自动变量和局部静态变量，由于a返回的是值，因此返回一个局部变量是可以的，无论自动还是静态，因为这时候返回的是这个局部变量的值，但不应该返回指向局部自动变量的指针(地址)，因为函数调用结束后该局部自动变量被抛弃，这个指针指向一个不再存在的对象(野指针)，是无意义的。但可以返回指向局部静态变量的指针，因为静态变量的生存期从定义起到程序结束。

3. 如果函数的返回值非要是一个局部变量的地址，那么该**局部变量一定要申明为static类型**。如下

   ```c++
   
       #include <stdio.h>   
       char *returnStr()   
       {   
           static char p[]="hello world!";   
           return p;   
       }   
       int main()   
       {   
           char *str;   
           str=returnStr();   
           printf("%s\n", str);   
         
           return 0;   
       }  
   ```

4. 数组是不能作为函数的返回值的，原因是***\*编译器把数组名认为是局部变量（数组）的地址\****。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。如下：

   ```c++
   
       int* func( void )  
       {  
           static int a[10];  
           ........  
           return a;  
       }   
   
   
   //返回static数组的首元素的地址
     char *getClassName(void)  
       {  
           static char className[50] = {0};  
           ......  
         
           return &className[0];  
       }  
   ```

5. 返回**指向堆内存的指针**(调用malloc函数得到的指针)是可以的

   ```c++
   
       char *GetMemory3(int num)  
       {  
       　　char *p = (char *)malloc(sizeof(char) * num);  
       　　return p;  
       }  
       void Test3(void)  
       {  
       　　char *str = NULL;  
       　　str = GetMemory3(100);  
       　　strcpy(str, "hello");  
       　　cout<< str << endl;  
       　　free(str);  
       }
   ```

   

 程序在运行的时候用 malloc 申请任意多少的内存,程序员自己负责在何时用 free释放内存。动态内存的生存期由程序员自己决定,使用非常灵活。





### 函数的分文件编写

函数分文件编写一般有4个步骤

1. 创建后缀名为.h的头文件

2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义



### 文件重定向

![image-20210412095323325](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20210412095323325.png)



## 指针

### 指针所占空间大小

不管什么类型的指针，在32位操作系统下:占用4个字节空间，64位下占8个字节



#### 空指针不能进行访问

`int *p = NULL;`则不可以操作*p，但可以操作p     空指针的作用：对指针进行初始化

0~255之间的内存编号是系统占用的，因此不可以访问



野指针   指针变量指向非法的内存空间



### const修饰指针

一句话总结：

如果const位于\*的左侧，则const是用来修饰指针所指向的变量，即指针指向的内容为常量；若const位于\*的右侧，const就是修饰指针本身，指针本身是常量（指针的指向不能改变）。

cont修饰指针有三种情况:

1.  const修饰指针---常量指针  `const int*p = &a`;

![image-20211029130755074](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211029130755074.png)

   特点：指针的指向可以修改，但是指针指向的值不可以通过指针`*p`修改

   ```c++
*p = 20;// 错误   但此时可以写a=20来改变a的值，只是不能通过*p来改变
   p = &b;//正确
   ```

   

2. const修饰常量---指针常量  `int *const p = &b;`
   ![image-20211029130813404](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211029130813404.png)

   ```c++
   *p = 20;//正确  可以通过指针修改变量的值
   p = &b;//错误指针的指向不可以修改
   ```

   

3. const即修饰指针，又修饰常量  `const int* const p = &b;`
   指针的指向和指针指向的值都不可以改



注意，不能修改指针常量的指向，不能通过指针修改常量指针的值。

不能修改指针指向的是指针常量，所以指针常量在定义时必须初始化，因为不能为其赋值。但是常量指针定义时可以不用初始化，因为常量指针可以修改其指向。



普通指针不能指向常量，错误的例子:

```c++
const int a = 10;
int *p = &a;//error  报错

const int a = 10;
const int *p = &a;//正确
```





### 函数指针

```c++
#include<iostream>
using namespace std;

int max(int a,int b){
	return a>b?a:b;
}

int main(){
	int(*p)(int,int) = max;
	cout << p(1,2) << endl;
}
```

![image-20211107142112050](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107142112050.png)





## const修饰符

将一个对象限定为只读，不能修改其值，故必须要在定义时对其进行初始化

```c++
const int a = 10;
const double PI = 3.14;//若修改变量PI的值，会报编译错误
```

在任何**函数之外**定义的const对象的作用域默认为**文件作用域**，只在定义该const对象的文件内有效。若希望定义一个全局作用域的const对象，要加上extern关键字。



### 常量表达式constexpr

**值不会改变而且在编译过程中就能确定结果的表达式**

```c++
const int size = 220;//是常量表达式
const int max = get_size();//max不是常量表达式，因为只有在运行时才能确定max的值
```

可以将对象的类型声明为constexpr类型，以便编译器检查该对象的值是否是一个常量表达式，**通过这种方法可以获得编译时常量**

```c++
constexpr int size = 20;//常量表达式
constexpr int my_size = size + 10;//也是常量表达式
```



与const的区别

```c++
constexpr int a = length();//必须在编译时能确定length函数返回值
const int b = length();//b的值可以在运行时再获得，并且之后不再改变
```

大多数情况下两者没有区别，但若b是全局作用域中的对象，编译器一定会为其分配空间

而对于a，如果没有代码明确要使用他的地址，编译器可以选择不为a分配存储空间，而进将其当作编译时期的值



## auto

auto声明的变量必须被初始化

auto并非是一种类型声明，而是一个类型声明时的占位符，编译器在编译时会将auto替换为变量实际的类型



## new

new在动态内存（堆）中为对象分配空间，并返回一个指向该对象的指针

new分配的数组大小不必是常量，可以在运行时指定

```c++
int* ip = new int;
*ip = 512;
delete ip;//ip成为野指针
int x;
ip = &x;//还可以使用ip指针
```



### delete

```c++
int *p = new int[100];
delete[] p;//释放数组内存空间
```

**注意注意**！若想要delete一个内存区域，则必须要先new，或者先定义，不能释放一个野指针指向的内存区域，否则一定会出问题（你可以认为，程序不知道delete到何时结束）

使用new申请的内存，释放时用delete，使用new [ ]申请的内存释放时要用delete [ ]才行，这两个一定要记住，申请时用了方括号，则释放时也要加上方括号，否则就会出错。

#### 基本数据类型

基本数据类型创建数组时，可以使用delete[]，也可以使用delete，因为基本的数据类型对象没有析构函数，并且new 在分配内存时会记录分配的空间大小，则delete时能正确释放内存，无需调用析构函数释放其余指针。因此两种方式均可。

#### 自定义数据类型（class）

这里一般指类，假设通过new申请了一个对象数组，注意是对象数组，返回一个指针，对于此对象数组的内存释放，需要做两件事情：一是释放最初申请的那部分空间，二是调用析构函数完成清理工作。对于内存空间的清理，由于申请时记录了其大小，因此无论使用delete还是delete[ ]都能将这片空间完整释放，而问题就出在析构函数的调用上，当使用delete时，仅仅调用了对象数组中第一个对象的析构函数，而使用delete [ ]的话，将会逐个调用析构函数。




**在删除一个指针之后，一定将该指针设置成空指针（即在delete *p之后一定要加上： p=NULL）**





## 构造函数

推荐使用构造函数初始化列表

```c++
class Student{
public:
    Student(int val):name("sc"),stu(201964055){
private:
        string name;
        int stu;
    }
}
```

可以初始化const，引用变量











## 引用

引用的初始值必须是一个有内存地址的对象，如变量

```c++
int ival = 10;
int &refVal = ival;//可以
int &refVal = 10;//不可以，10数值存储在常量区，不能对其地址进行操作
```



### 起别名

注意：

1. 引用必须初始化，即声明时就要初始化
2. 引用在初始化后不能进行改变了(不能再作为别的元素的别名)
3. 声明一个引用，并不是重新定义了一个变量，他只是表示该引用是目标变量名的一个别名，所以**系统不会给引用分配存储单元**
4. 对引用求地址，就是对目标变量求地址



由于指针变量也是变量，所以可以声明一个指针变量的引用，具体程序如下

```c++
	int *a;
	int* &p = a;
	int b = 10;
	p = &b;
	cout << *p << endl;
	cout << *a << endl;
```



### 指针变量的引用



```c++
int a = 1;
int *pa = &a;
int *&p = pa;//p是pa指针的别名
```



### 引用做函数参数

1. 不要返回局部变量的引用
2. 若函数的返回值是一个引用，则函数的调用可以作为左值



### 引用作函数返回值

定义函数时需要在函数名前加&

使用引用返回函数值的最大好处是，在内存中不产生返回值的副本



### 注意

1. **不能建立数组的引用**，因为数组是一个由若干个元素所组成的集合。

2. 引用是对某一变量或目标对象的引用，它本身并不是一种数据类型，因此**引用本身不占存储单元**，这样，就不能声明引用的引用，也不能定义引用的指针。

3. 不能建立空指针的引用，也不能建立空类型的引用

   ```c++
   void &a = 10;//错误
   int &a = NULL;//错误
   ```




### const修饰引用

声明方式： const 类型标识符 &引用名 = 目标变量名

```c++
int b = 10;
const int &a = b;
```

通过这种方式声明的引用，不能通过引用对目标变量的值进行修改，从而使引用的目标成为const，达到了保护目标变量的目的。  但是可以通过b对变量的值进行修改



### 说明

![image-20211107153624423](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107153624423.png)



### 右值引用

类型名 && 引用名 表达式

- 不能取地址的，没有名字的就是右值
- 匿名变量，临时变量的别名

例如

```c++
int && sum = 3+4;
float && res = ReturnRvalue(f1,f2);
```

![image-20211107153946430](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107153946430.png)





## 动态内存分配

### 自动存储

- 在程序块内定义的自动变量
- 在程序运行时自动产生，并自动消亡

### 静态存储

- 在函数外定义的全局变量，或在代码块内用static定义的局部变量
- 在编译时就确定占用存储空间的大小，在程序运行时可用，并直到程序结束时消亡。

### 动态存储

采用new和delete管理内存，由程序员控制内存的持续时间，不是由一组固定的规则控制，内存块可以在一个函数中创建，在另一个函数块中释放。

- malloc原型  void *malloc(字节数)   该函数若分配内存成功，则返回其起始地址，否则返回NULL    stdlib.h

new与delete的区别

![image-20211107154800944](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107154800944.png)





释放内存

![image-20211107154825952](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107154825952.png)

# 函数

一个函数内部不能定义别的函数，即**不允许嵌套定义**



## 函数的声明

函数的声明不需要写形参的名称，只需要写形参的个数和类型即可

## 函数的缺省值

从右侧开始，不能左边的形参有缺省值，右边的形参没有缺省值。但是可以右边的形参有缺省值，左边的形参没有缺省值。



函数的声明与定义分开时，默认参数只能放在声明中，不能放在定义中。



## 实参与形参

实参与其对应的形参各自占据独立的存储单元

形参与实参类型不同时，以形参类型为准，进行隐式类型转换

函数的形参只有在调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元



## 函数返回值

在函数中允许有多个return语句（通常在条件判断语句中），但只有一个return执行



不加返回值类型的函数，自动按整型处理。

```c++
show(){
	double a = 100.5;
	return a;
}


int main(){
	cout << show() << endl;//100
}
```

函数返回值类型应该与函数定义的类型一致，若不一致则以函数定义的类型为准。进行类型转换。





## 函数传参数



 **这里有个特殊情况，就是对于多态的情况，**如果形参是父类，而实参是子类，在进行值传递的时候，临时对象构造时只会构造父类的部分，是一个纯粹的父类对象，而不会构造子类的任何特有的部分，因为有虚的析构函数，而没有虚的构造函数，这一点是要注意的。如果想在被调函数中通过调用虚函数获得一些子类特有的行为，这是不能实现的



从参数检查上讲。一个健壮的函数，总会对传递来的参数进行参数检查，保证输入数据的合法性，以防止对数据的破坏并且更好地控制程序按期望的方向运行，在这种情况下使用值传递比使用指针传递要安全得多，因为你不可能传一个不存在的值给值参数或引用参数，而使用指针就可能，很可能传来的是一个非法的地址（没有初始化，指向已经delete掉的对象的指针等）。所以使用值传递和引用传递会使你的代码更健壮，具体是使用引用还是使用，

**最简单的一个原则就是看传递的是不是内建的数据类型，对内建的数据类型优先使用值传递，而对于自定义的数据类型，特别是传递较大的对象，那么请使用引用传递。**



### 注意

1. 使用引用传递参数的函数，在内存中并没有产生实参的副本，它是直接对实参操作。
2. 使用一般变量传递参数的函数，当发生函数调用时，需要给形参分配存储单元，这样实参与形参就占用不同的存储单元，所以形参变量的值是实参变量的值的副本。
3. 因此，当参数传递的数据量较大时，用引用比用一般变量传递参数的**效率高**和**占用空间少**。
4. 使用指针作为参数的函数虽然也能和使用引用达到相同的效果，但是在被调用函数中需要重复采用"\*指针变量名"的形式进行运算，这很容易产生错误并且程序的可读性较差；另一方面，在主函数的调用点处，必须用变量的地址作为实参。





### 如何使被调用函数同时返回多个值

![image-20211107144648319](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107144648319.png)



## 外部变量

![image-20211107163429129](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107163429129.png)

寄存器变量

![image-20211107163433707](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107163433707.png)









## 内联函数





![image-20211107172253727](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107172253727.png)

C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(**注意是定义而非声明**，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开



关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。

代码如下:

```c++
inline void Foo(int x, int y);  // inline 仅与函数声明放在一起 
void Foo(int x, int y)
{
 ...
}
```

而如下风格的函数 Foo 则成为内联函数：

代码如下:

```c++
void Foo(int x, int y); 
inline void Foo(int x, int y)  // inline 与函数定义体放在一起
{
 ...
}
```

所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，但我认为 inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。



定义在类声明之中的成员函数将自动地成为内联函数，例如：





## 带默认形参值的函数

默认参数一般在函数说明中提供

- 若程序中既有函数的说明，又有函数的定义时，定义函数时不允许再定义参数的默认值。
- 如果程序中没有函数的声明，只有函数的定义，则默认参数才可以出现在函数定义当中。
- 如果一个函数中有多个默认参数时，在形参列表中，应该从右向左定义。



## 追踪返回类型的函数

![image-20211107173546355](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107173546355.png)

如此这样，就可以由编译器来推导Sum函数模板的返回类型。



与普通函数返回类型的区别：

1. 返回类型后置

```c++
1  // 普通函数声明
2  int func(char* a, int b);
3 
4  // 追踪返回类型的函数声明
5  auto func(char* a, int b) -> int;
```

2. 



# 类

## 定义类

用class定义类，类中不给修饰符，默认是private

用struct定义类，与class定义的唯一区别：类中不给修饰符时，默认是public

#### public、protected、private的区别

![image-20211026094249643](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211026094249643.png)



### 定义成员函数

> 成员函数是所有对象所共有的

两种方法：

1. 在类中直接写，适用于成员函数规模较小的情况，他们一般为内联函数，即使没有使用inline关键字

2. 在类外定义。在类中只给出成员函数的原型，而成员函数的定义放在类的说明之后，适用于成员函数体较大的情况
   在函数的名称之前加上其所属类名和作用域运算符"::"

   ```c++
   class T{
       public:
       void show();
       static void Print();
   };
   void T::show(){
       cout<< "" << endl;
   }
   
   void T::Print(){
       //...
   }
   ```



在默认函数定义上加上=default，可显示地指示编译器生成该函数的默认版本





#### delete

成员函数=delete，表明成员函数不可以被调用

![image-20211029002543827](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211029002543827.png)

普通函数也可以=delete，不只是成员函数可以





### 静态变量

静态变量在被创建时，自动赋值0.自动变量初始值不确定



#### 静态全局变量

在全局变量前加上一个static关键字，该变量就被定义成了一个静态全局变量，该变量只在定义它的源文件中可见，严格讲应该为从定义之处开始到本文件的末尾，静态全局变量不能被其他文件所用。

**可以使用静态局部变量来解决返回局部变量时编译器发出的警告**



#### ==静态成员变量==

> 静态成员变量（对象）与全局变量在一个地方存储（全局区），只是作用域不一样，若多次创建一个同名的静态对象，则只会创建一次，下一次发现全局区有这个变量之后，就跳过该创建变量的语句，不再管他了



静态数据成员被类的所有对象所共享，包括该类的派生类的对象，即派生类对象与基类对象共享基类的静态数据成员。==static成员在整个继承集体中只有一个，派生类对static成员的修改使得基类的static成员也得到了修改，这显然不是继承的特征==。实际上，static成员不是通过继承得到的，而是通过编译时静态绑定得到的。



例子如下：

```c++
#include<iostream>
using namespace std;

class Sample{
	public:
		Sample(){
			cout << "Construct!" << endl;
		}
};
void fn(int i){
	static Sample c;
	cout << "i=" << i <<  endl;
}
int main(){
	fn(10);
	fn(20);
}
//程序的输出：
/*
Construct!
i=10
i=20
*/
```

定义数据成员为静态变量，表明此数据逻辑上属于该类；定义成员函数为静态函数，表明此全局函数逻辑上属于该类，而且该函数只对静态数据，全局数据或者参数进行操作，而不能对非静态数据成员进行操作。



```c++
class A{
    int n;
    static int s;
}
```

sizeof运算符不会计算静态成员，sizeof(A)=4。使用静态数据成员可以节省内存，因为他是所有对象所共有的，因此，对于多个对象来说，静态数据成员只存储一处，供所有对象使用。

```c++
class A{
	int a;
	int b;
};

class B{
	int a;
	static int b;
};

int main(){
	cout << sizeof(A) << endl;//8
	cout << sizeof(B) << endl; //4
}
```



**静态成员初始化必须在类的外面初始化**，初始化格式：

<数据类型><类名>::<静态数据成员名>=<值>



如果一个类中声明了静态数据成员，只有该类的第一个实例被创建时才进行初始化，自第二个对象起均不进行初始化，对A中静态成员s初始化为

```c++
int A::s = 0;
```

初始化在类体外进行，前面不加static以免与一般静态变量或对象相混淆。

因此，**静态数据成员是类的成员，不是对象的成员**

引用静态数据成员时，采用如下格式：<类名>::<静态成员名>

类为静态数据成员只分配了一块存储空间（不管类有多少个实例）。什么时候该定义静态数据成员呢？==如果一个数据是类的所有成员都需要的，而且这个数据的变化对于这个类的所有实例来说都是统一的，则就把该数据定义为静态数据成员==



**静态数据成员被类的所有对象所共享，包括该类派生类的对象，即派生类对象与基类对象共享基类的静态数据成员**



##### 静态数据成员的类型

静态数据成员的类型可以是所属类的类型，而非静态数据成员则不可以，非静态数据成员只能声明为所属类型的指针或引用

例子：

```c++
class Student{
	static Student stu;
	//Student mstu; //报错，非静态数据成员只能声明为所属类的指针或者引用
	Student* pstu;
	Student& ystu;
};
```





#### 静态成员函数

静态成员函数也不会被派生类所继承，同样是编译时静态绑定。同静态数据成员一样，静态成员函数是被类的所有对象所共享，包括该类派生类的对象。

如果在派生类中有一个静态成员函数，函数名与父类中的静态成员函数相同，这实际上是两个相互独立的成员函数。（调用时采用类的限定符：：，或通过类的对象来访问）



若通过类的对象来访问时，没有什么疑问；若是通过类的对象的指针或引用来访问静态成员函数，则一定是静态联编。（访问非静态成员函数也是一样）



## 构造函数

使用带默认参数的构造函数时，要防止二义性

```c++
Myclass();
Myclass(int i = 10);
//此时若使用一个无参数构造方法创建对象，则会产生二义性
```

#### 构造函数的初始化列表

类名(形参表)：数据成员1（初值1），数据成员2（初值2）...

{...}



#### 初始化顺序

成员的初始化顺序与成员的声明顺序相同；

成员的初始化顺序与初始化列表中的位置无关；



1. 成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。这点在EffectiveC++中有详细介绍。
2. 如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
3. 注意：类成员在定义时，是不能初始化的
4. 注意：类中const成员常量必须在构造函数初始化列表中初始化。
5. 注意：类中static成员变量，必须在类外初始化。
6. 静态变量进行初始化顺序是基类的静态变量先初始化，然后是它的派生类。直到所有的静态变量都被初始化。这里需要注意全局变量和静态变量的初始化是不分次序的。这也不难理解，其实静态变量和全局变量都被放在公共内存区。可以把静态变量理解为带有“作用域”的全局变量。在一切初始化工作结束后，main函数会被调用，如果某个类的构造函数被执行，那么首先基类的成员变量会被初始化。





#### 最好使用初始化列表

从概念上来讲，构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段.

**初始化阶段**
所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中.

**计算阶段**
一般用于执行构造函数体内的赋值操作。



初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。
主要是性能问题，对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，但是对于类类型来说，最好使用初始化列表，为什么呢？由下面的测试可知，**使用初始化列表少了一次调用默认构造函数的过程**，这对于数据密集型的类来说，是非常高效的。**能使用初始化列表的时候尽量使用初始化列表**



除了性能问题之外，有些时候初始化列表是不可或缺的，以下几种情况时必须使用初始化列表

1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面

3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化



```c++
class Test1 
{ public:
 Test1(int a):i(a){}
 int i;
};

class Test2
{ public: 
 Test1 test1 ;
 Test2(Test1 &t1) 
 {test1 = t1 ;}S
};
```

以上代码无法通过编译，因为Test2的构造函数中test1 = t1 这一行实际上分成两步执行：

1. 调用Test1的默认构造函数来初始化test1
   由于Test1没有默认的构造函数，所以1 无法执行，故而编译错误。

   

   正确的代码如下，使用初始化列表代替赋值操作

```c++
class Test2
{
public:
Test1 test1 ;
Test2(int x):test1(x){}
};
```



成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的

```c++
class foo
{
public:
int i ;int j ;
foo(int x):j(x), i(j){} // i值未定义
};
```

这里i的值是未定义的因为虽然j在初始化列表里面出现在i前面，但是i先于j定义，所以先初始化i，而i由j初始化，此时j尚未初始化，所以导致i的值未定义。一个好的习惯是，按照成员定义的顺序进行初始化。





初值可以是**常量**或**形参表中的参数**

```c++
class Date{
    public:
    Date():year(2000),month(1),day(1){};
    Date(int y,int m,int d):year(y),month(m),day(d){}
    private:
    int year,month,day;
}
```



#### 带默认参数的构造函数

带默认参数的构造函数不要与构造函数的重载在一起使用，否则可能会造成二义性。



#### 委派构造函数

在构造函数的**初始化列表**中调用其他构造函数，称为**委派构造函数**

![image-20211022010614179](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211022010614179.png)



### 拷贝构造函数

类名（[const] 类名 &形式参数）{

}

1. 名称与类的名称相同，但==他只有一个参数==，**该参数就是对一个该类对象的引用**
2. 必须传递引用，不能使用值
3. 拷贝构造函数的功能是，通过将一个同类型对象的值拷贝给一个新对象，**来完成对新对象的初始化**

出现在以下位置：

- 初始化式
- 参数传递

![image-20211022011355107](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211022011355107.png)



#### 默认的拷贝构造函数

功能：把作为参数的对象的数据成员逐个拷贝到目标对象中，这称为**成员级复制**（浅拷贝）

若有指针变量，会造成两者绑定！！修改其中一个，另外一个也会跟着修改![image-20211022012107701](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211022012107701.png)

故对象属性含有指针变量，要实现深拷贝，即对指针变量重新new一片内存区域，让新的对象的指针变量值指向该区域，并进行值拷贝，而不是地址拷贝![image-20211022012659442](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211022012659442.png)



#### 函数返回局部对象

返回局部对象时，会调用一个拷贝构造函数，参数是t，然后t释放；也可能是调用重载赋值运算符，这要看外面怎么调用这个运算符+

- 若是Complex d = 3.5 + c;就是拷贝构造函数
- 若是Complex d;
  d = 3.5 + c;就是重载赋值运算符

```c++
Complex& operator+(int x,const Complex &c){
	Complex myc(c);
	myc.a = c.a + x;
	return myc;
}
```

但是，不管怎样，编译器会出现警告，疑惑：警告存在的意义是什么？

答：可以在Complex前加上static，来消除警告，静态局部对象在执行完毕之后不会被释放





### 移动构造函数

详见博客

http://c.biancheng.net/view/7847.html



当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数



#### return一个局部对象时

分两种情况

1. 若该类没有移动构造函数，则调用拷贝构造函数把临时对象赋值给一个副本，然后再调用拷贝构造函数将该副本赋值给外面要创建的对象（调用两次拷贝构造函数）
2. 若该类有移动构造函数，则调用移动构造函数把临时对象传递给一个副本，然后再调用移动构造函数将该副本传递给外面要创建的对象（调用两次移动构造函数）



### 转换构造函数

一个构造函数接收一个不同于其类类型的形参，可以视为将其形参转换成类的一个对象。像这样的构造函数称为转换构造函数。

除了创建类对象之外，转换构造函数还为编译器提供了执行隐式类型转换的方法。只要在需要类的类型值的地方，给定构造函数的形参类型的值，就将由编译器执行这种类型的转换。

看下面这个类：

```c++
class IntClass
{
    private:
        int value;
    public:
        //转换int的转换构造函数
        IntClass(int intValue)
        {
            value = intValue;
        }
        int getValue() const { return value; }
};
```

由于构造函数 IntClass(int) 只接收一个类型不同于 IntClass 的单个形参，所以它是一个转换构造函数。



##### 转换构造函数的形式

![image-20211028232040384](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211028232040384.png)



##### 实例

string 类提供一个将 C 字符串转换为 string 的转换构造函数

```c++
class string
{
    //仅显示转换构造函数
    public:
        string(char *)；
};
```

该转换构造函数的存在允许程序员将 C 字符串传递给需要 string 对象形参的函数，将 C 字符串赋值给 string 对象，并使用 C 字符串作为 string 对象的初始值：

```c++
string str = "Hello";
str = "Hello There!";
```

在某种意义上，转换构造函数的工作方式与前面介绍的类型转换运算符刚好相反：类型转换运算符是将一个对象转换为其他类型的值，而转换构造函数则是将给定类型的值转换为类的对象。





## 析构函数

一个类只能有一个析构函数，析构函数不能重载

- 对于一个简单的类来说，大多可以直接使用系统提供的默认析构函数
- 但是如果在类的对象中有动态分配的内存（成员变量有指针变量）时，就必须为该类提供适当的析构函数，完成清理工作（释放内存）









## 类作用域

注意：在类中定义的静态数据成员和静态成员函数还具有外部的连接属性。

::



## 对象成员

![image-20211107212810386](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107212810386.png)

![image-20211107212823063](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107212823063.png)













### 类型转换函数

- 强制类型转换运算符重载函数
- 将一个类的对象转换成另一种类型的数据
- ![image-20211028232620902](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211028232620902.png)

- 只能是类的成员函数

如：

```c++
class Complex{
    ...
       operator double(){
        return r;
    }
}
```



### 常成员函数与常数据成员

在类的一般函数成员中依然可以访问const类型的数据成员。



#### 常成员函数

==非常对象也可以使用常成员函数，若一个成员函数不对对象作出修改，就可以将其写为常成员函数，这是一种好习惯。==

① 首先，常成员函数内部不允许进行数据成员的修改，但是可以在函数内部输出const数据成员与非数据成员！

② 其次，还可以区分同名构造函数，举个例子（如下）：

```c++
#include <iostream>
using namespace std;
 
class Test
{
public:
	void Show()const
	{
		cout << "Hello,Const!" << endl;
	}
	void Show()
	{
		cout << "Hello!" << endl;
	}
};
 
int main()
{
	Test t1;
	t1.Show();
	Test const t2;
	t2.Show();
	return 0;
}
```



#### 常对象

1. 在定义时应该进行初始化，而且其数据成员的值在整个生存期内不能被修改。

2. **只能调用类中常成员函数**

在 Dev C++ 中，常量对象如果使用无参构造函数初始化，就需要显式写出无参构造函数。



在类的实例化同时，加上const进行修饰实例化出的对象即可：

const修饰对象，直接限制了对象对其内部非const成员的访问，也就是说如果类中的数据成员与函数成员都没有被const修饰，

那么实例化出的常对象将无法对类进行操作；

当然，const对象是可以直接操作const成员的（数据成员、函数成员），所以这就需要我们把成员函数声明为const型；

```c++
#include <iostream>
using namespace std;
 
class Point
{
private:
	int x, y;
	const int e;
	static int count;
public:
	Point(int xx, int yy,int ee):e(ee),x(xx),y(yy)
	{
		count++;
	}
	void Show_C()const   //常函数内部无法对数据进行修改
	{
		cout << "C = " << c << endl;
		cout << "D = " << d << endl;
	}
	static int Show_Count()
	{
		return count;
	}
	int c = 250;
	const int d = 360;    //可以直接在声明的时候赋值
};
 
int Point::count = 0;
 
int main()
{
 
	Point const P1(1, 2, 3);    //这里的const直接限制了在外部对类中public中数据成员的修改
 
	cout << P1.d << endl;    //const int d = 360;
 
	P1.Show_C();
 
	return 0;
}
```



### 静态成员

C++类还有一种成员，称作静态成员，静态成员是同一个类的所有对象公有的。

- #### 静态数据成员

  ![image-20211026010718127](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211026010718127.png)

  ![image-20211026010733236](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211026010733236.png)

  

- #### 静态成员函数
  

![image-20211026010848195](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211026010848195.png)

  一个静态成员函数不与任何对象相关联，所以它不能访问非静态成员

1. 访问静态成员函数和静态成员变量时，与Java不同，要使用A::s    A::fun()

2. 可以通过类的对象来访问类的静态数据成员和静态成员函数（与Java类比，确实可以，但没什么用）

3. 类的非静态成员函数可以调用类的静态成员函数
4. 静态成员函数可以在派生类中被重定义，但是静态成员函数不能为vitural函数，因为virtual函数由编译器提供了this指针，而静态成员函数没有this指针
5. 静态成员函数也不能被声明为**const**类型







静态成员变量与静态成员函数访问实例：

```c++
#include<iostream>
using namespace std;

class A{
	public:
	static int a;
	static void fun(){
		cout << "static tools!" << endl;
	}
	static int getN(){
		return a;
	}
};

int A::a = 0;

int main(){
	A a;
	A::fun();//通过类名访问静态成员函数 
	a.fun();//通过对象访问静态成员函数 
	cout << a.getN() << endl;
	cout << a.a << endl;//通过对象名访问静态数据成员
	cout << A::a << endl;//通过类名访问静态数据成员 
	return 0;
}
```



### 自定义类型转换

#### 方法一

![image-20211028235854138](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211028235854138.png)



#### 方法二









### 强制类型转换



# 内存分区模型

C++程序在执行时，将内存大方向划分为4个区域

程序运行前：

- 代码区:存放函数体的二进制代码，由操作系统进行管理的·
  存放CPU执行的机器指邻
  代码区是**共享**的。共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令
- 全局区:存放全局变呈和静态变呈以及常量
  全局变量，静态变量，全局**常量**，字符串**常量**
  **不在全局区的量：局部变量，const修饰的局部变量**



程序运行后：

- 栈区∶由编译器自动分配释放,存放函数的参数值,局部变量等   形参
  **不要返回局部变量的地址**，局部变量存放在栈区，栈区的数据要在函数运行完之后释放

- 堆区:由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收
  主要利用new开辟堆区内存   new返回的是该数据类型的指针

  ```c++
  int *p = new int(10);
  return p;//10的地址
  delete p;//释放堆区内存，存储int类型指针
  ```

  new数组

  ```c++
  int *arr = new int[10];
  delete [] arr;//释放数组类型的指针
  ```

  







### 静态类成员

在定义静态数据成员时，通常需要在类体外部对静态数据成员进行初始化。

静态成员可以通过类名访问，也可以通过对象访问。  在一个类中，静态数据成员是背所有的类对象所共享的，无论定义多少个对象，类的静态数据成员只有一份。若某一个对象修改了静态数据成员，其他对象的静态数据成员也将改变。

- 静态数据成员可以是当前类的类型，而其他数据成员只能是当前类的指针或应用类型。
- 静态数据成员可以作为成员函数的默认参数，类的普通数据成员不能作为默认参数。
- 类的静态成员函数只能访问类的静态数据成员，而不能访问普通的数据成员。
- 静态成员函数不能定义为const成员函数。
- 在定义静态数据成员函数时，如果函数的实现代码处于类体之外，则在函数的实现部分不能再标识static关键字



### this

在每个类的成员函数（非静态成员函数）中都隐含包含一个this指针，指向被调用对象的指针，其类型为当前类类型的指针类型。



### 嵌套类

CList中定义了一个嵌套类CNode，CNode定义了一个私有成员m_tag，对于外围类CList中，通常他不能够访问嵌套类的私有成员，但是若CNode将CList作为自己的友元类，则CList类可以访问CNode类的私有成员

嵌套类只允许在外围类中使用



# 友元

> 友元函数和友元类可以被声明为私有的或者公有的，public或者private

如：通过友元函数来创建构造函数被设为私有的类的对象

## 友元函数



注意：因为友元函数不是任何类的成员函数，所以在类内声明友元函数，在类外定义时，函数名之前（或重载的运算符之前）**千万不要加   类名::**，加了就相当于承认了该函数是该类的成员函数。  



1. 友元函数可以提高程序的效率

2. 友元函数在友元类中声明，这样函数在类的外部也可以不调用get方法就可以访问类的内部的private和protected属性的值。虽然友元函数在类中声明，**但是它并不是该类的成员函数**

3. 友元函数不仅可以是某一个类的成员函数，还可以是一个全局函数
4. 一个函数可以是多个类的友元函数，只需在各个类中分别声明
5. 不允许将某个类的构造函数，析构函数，和虚函数声明为友元函数









在友元函数中要对类的成员进行访问，**必须在参数表中显示指明要访问的对象**





1. 友元函数可以声明为public，private，protected，都可以，因为它并不是类的成员函数，所以不论将他放在什么区段都不影响他发挥作用。
2. 可以将别的类中的成员函数声明为友元函数
   - 提前声明要使用的类
   - 必须将先定义的类的成员函数作为后定义类的友元函数，调换顺序会出现语法错误
3. 可以通过友元函数来创建构造函数被设置为私有的类的对象





## 友元类

在另一个类中访问当前类的私有成员（方法和属性）

若B被声明为A的友元类，则B中所有的函数都是A的友元函数

友元类**不具有对称性**，**也不具有传递性**







## 命名空间

可以定义嵌套的命名空间，双重前缀

可以是全局的，也可以嵌套定义，但是不能在代码块中定义（不能在函数中定义）

![image-20211107174437575](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107174437575.png)



### 重定义错误

```c++
namespace Tom{
	int count = 0;
}

int main(){	
	using Tom::count;
	int count = 2;//重定义报错
    
}
```





使用全局空间中的count变量

```c++
namespace Tom{
	int count = 0;
}

int count = 2;
int main(){	
	using Tom::count;
	cout << ::count << endl;//2
}
```

分开使用

```c++
namespace Tom{
	int count = 0;
}

int count = 2;
int main(){	
	//using Tom::count;
	double count = 100.2;
	cout << count << endl;
	cout << ::count << endl;
	cout << Tom::count << endl;
}
```





### 未命名的命名空间

![image-20211107175823816](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211107175823816.png)





### using编译指令与using声明的区别

形式不同：

1. using 声明：using 名称空间名 :: 名称 例如：using Jill:: fetch；//这是一个using 声明。
   using 编译指令：using namespace 名称空间名 例如： using namespace Jill;//这是一个using 编译指令
2. using声明使名称空间中的特定标识符可用，例如 using Jill:: fetch;只有fetch这个名称可用；
   而using 编译指令使得名称空间里得所有标识符可用。例如using namespace Jill 使得Jill空间里的所有名称可用。
3. 使用using 声明时，如果某个名称已经申明了，就不能使用using导入相同的名称。
   using 编译指令导入所有的名称，如果与局部名称发生冲突，则局部名称称将覆盖名称空间版本，而编译器不会发出警告



# 继承

**父类中的private成员被继承后不能被访问，而且父类的**构造函数**和**析构函数**不能被继承

基类的**私有成员**和**不可访问成员**在子类中不可访问

若想在子类中使用父类的构造函数，则需要加上

```c++
public:
	using Father::Father;
```



### 派生类的构造函数和析构函数

派生类的构造函数和析构函数不能从父类继承，必须重新定义，定义格式如下:

![image-20211026095235941](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211026095235941.png)



构造派生类对象时，要对其基类数据成员，所含成员对象以及其他的新增数据成员一起进行初始化，这种初始化工作是由派生类的构造函数来完成的。



派生类的成员包含两部分：

1. 从基类继承的成员
2. 自身定义的成员

所以，对派生类对象的初始化也就包含两部分：首先对基类继承来的成员进行初始化，再对新增成员进行初始化。由于基类的构造函数不能继承，所以派生类的构造函数必须通过调用基类的构造函数来初始化从基类继承来的成员。因此，**派生类的构造函数除了对新增加的数据成员进行初始化外，还必须负责调用基类构造函数，使从基类继承来的成员得以初始化**。





#### 继承基类的构造函数

```c++
public:
	using Base::Base;
```

基类构造函数的参数默认值不会被派生类继承，但由默认参数导致的多个构造函数版本都会被继承。

![image-20211108014213731](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211108014213731.png)



![image-20211108014225635](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211108014225635.png)









### 共有型派生public

对于基类中的public数据成员和成员函数，在派生类中仍然是public，对于基类中的private数据成员和成员函数，在派生类中仍然是private，基类中的protected成员在子类中也还是protected。但是派生类无法访问基类中的private数据成员



特例：

==对于基类中的protected成员，可在public派生下通过using声明改为public成员==

于是，在基类中的protected成员同public成员一样，可以在派生类中任何地方使用using声明

### 私有型派生private

**采用private私有派生，基类所有的公有和保护成员在派生类中都成为私有成员，只允许在派生类的成员函数中访问基类的非私有成员。**

对于基类中的public，protected数据成员和成员函数，在派生类中可以访问。基类中的private数据成员，在派生类中中不可访问

private继承时，基类的成员函数（非private）可以在子类中被使用，但不可以用子类的对象使用



```c++
#include<iostream>
using namespace std;

class B{
	public:
		void f(){
			cout<< "B::f()..." << endl;
		}
};

class D1 : public B{
	
};


class D2 : private B{
	public:
		void g(){
			cout<< "D2::g(),calling f()..." << endl;
			f();
		}
};


int main(){
	D2 d2;
	d2.g();//虽然D2是private继承，但是可以使用子类D2的成员函数g()调用基类B中的方法
	//d2.f();//但是子类的对象不可以调用基类中的f()方法，因为是private继承，f()方法在子类中已经成为private的
	D1 d1;
	d1.f(); //由于D1是public继承，所以在D1中，f()方法仍然是public，可以直接被D1的对象d1调用 
}
```



### 保护型派生protected

**采用protected保护派生，基类所有的公有和保护成员在派生类中都成为保护成员，只允许在派生类的成员函数和该派生类的派生类的成员函数中访问基类的非私有成员。**

对于基类中的public，protected数据成员和成员函数，在派生类中均为protected。**protected成员在派生类定义时可以访问，用派生类生成的对象不可以访问，也就是说在类体外不可以访问**。protected成员可以被基类的所有派生类使用，这一性质可以沿继承树无限向下传播。



### 单一继承

先调用基类的构造函数，然后调用派生类的构造函数。

从基类继承全部数据成员和成员函数（不包括构造和析构函数）

### 多重继承

基类构造函数被调用的顺序以类派生初始化表中声明的顺序为准。

![image-20211026111523706](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211026111523706.png)

#### 多重继承的二义性

![image-20211026111714960](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211026111714960.png)





##### 虚继承

虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。

虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要，因为这样只会降低效率和占用更多的空间。





例如菱形继承：

![img](https://img2020.cnblogs.com/blog/1809324/202003/1809324-20200325212630708-9501468.png)

 

 类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

假设类a是父类，b类和c类都继承了a类，而d类又继承了b和c，那么由于d类进行了两次多重继承a类，就会出现两份相同的a的数据成员或成员函数，就会出现代码冗余。同时，我们在d类的实例化对象中调用从a类继承来的数据成员或者成员函数的时候，无法分清是来自于b类或者是c类，会发生编译错误。这也就是我们常说的二义性。

故为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。那么解决这个问题的关键就是虚继承。

为了解决多继承时的命名冲突和冗余数据问题，[C++](http://c.biancheng.net/cplus/) 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

```c++
//间接基类A
class A{
protected:
    int m_a;
};
//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};
//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};
//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};
int main(){
    D d;
    return 0;
}
```

虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。



观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作。在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。

换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。

在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。

C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。

![虚继承在C++标准库中的实际应用](http://c.biancheng.net/uploads/allimg/200629/1-2006291K2591N.png)







##### 注意：

多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生

virtual修饰继承方式：

```
1 //继承的动作 虚继承
2 //父类：虚基类
3 class 子类:virtual public 父类
4 {
5 
6 };
```

vbptr（虚基类指针） 其中v是virtual 虚 b是base 基类 prt指针

（vbptr指向虚基类表）

vbtable(虚基类表 ） 保存了当前的虚指针相对于虚基类的首地址的偏移量

 

总结：之所以 产生 vbptr和vbtable 目的 保证 不管多少个继承 虚基类的数据只有一份。





### 派生类的构造函数

- 单继承派生类构造时，首先构造基类，其次是派生类的数据成员的初始化（**顺序和派生类数据成员的声明顺序相同**），最后执行派生类的构造函数
- 多重继承派生类构造时，首先构造虚基类，多个虚基类按照他们被继承的顺序依次构造；其次构造一般基类，多个一般基类按照被继承的顺序构造；然后初始化派生类的数据成员，初始化顺序和派生类数据成员的声明顺序相同；最后执行派生类的构造函数。



派生类的构造函数要负责调用基类的构造函数

- 派生类的构造函数除初始化新增的数据成员外，还必须对基类中的数据成员进行初始化
- 对基类数据成员的初始化由基类的构造函数完成，以避免类与类之间的相互干扰。



派生类的构造函数定义格式如下：

派生类构造函数名（总参数表） ：基类构造函数名（参数表）{

派生类中新增的数据成员初始化语句

}

**总参数表中包含基类构造函数所需的参数和对新增的数据成员初始化所需要的参数**



#### 派生类对象的构造与析构过程

![image-20211108013530279](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211108013530279.png)







# 多态

同样的消息（调用同名成员函数）被类的不同对象接收时导致完全不同的行为，c++语言通过**虚函数**实现运行时的多态性



编译看父类，运行看子类

1. 基类指针可以指向派生类对象（向下转型）

2. 派生类指针经强制类型转换后，可以指向基类对象（向上转型）

而且强制类型转换必须按照图中所示那样写：

![image-20211026113216959](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211026113216959.png)



### 赋值兼容规则

基类的指针可以指向派生类的对象，派生类的指针可以指向经过强制类型转换之后的基类对象。

赋值兼容规则的前提是public继承





### 静态联编

编译时看静态联编，运行时看动态联编

![image-20211026120137988](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211026120137988.png)

在c++中，Animal a = new Cat();若Animal中的show方法没有写virtual关键词，则调用a.show()会调用Animal中的show方法，而不会调用Cat中的。java中就会直接调用Cat中的show方法，比较人性化。



### 动态联编

根据对象的实际类型调用正确的成员函数

使用动态联编的方法：把基类中的函数定义为虚函数

在java中，父类性的引用指向子类型的对象，本身就是动态联编



### 虚函数

![image-20211026121405896](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211026121405896.png)



### 纯虚函数

若抽象类的派生类中没有全部定义基类中的纯虚函数，则需要将这个函数再次声明为一个纯虚函数，此派生类还是一个抽象类。

```c++
virtual 函数原型 = 0;//纯虚函数没有函数体
```

#### 抽象类

包含纯虚函数的类，叫做抽象类。

1. 抽象类只能用作**基类**来派生新类，不能声明抽象类的对象，但可以声明抽象类的指针变量和引用变量。（用作多态，父类型指针指向子类型对象，父类性的引用指向子类型对象）
2. 抽象类中可以定义纯虚函数和普通函数
3. 如果抽象类的派生类没有定义基类中的纯虚函数，则必须再将该函数声明为纯虚函数，因此派生类也是一个抽象类。



# 运算符重载

> 重载的运算符必须与自定义类型的对象一起使用，要求其参数至少有一个是自定义类型的对象

可以使用**成员函数***或者**全局函数**进行重载

流对象不能复制只能引用，比如传入函数当参数时。



- 不能定义新的运算符
- 重载运算符的函数不能包含有默认值的参数
- 重载的运算符必须与自定义类型的对象一起使用，要求其参数至少有一个是自定义类型的对象





#### <<重载

不能利用成员函数重载，因为无法实现cout在左侧，必须要用全局函数重载

结论：重载左移运算符配合友元可以实现输出自定义数据类型

```c++
class Complex{
public:
    friend ostream& operator<<(ostream &cout,const Complex &c);//写const是为了允许const类型也可以传给他，不是const类型也可以传给他；若不写，则const类型无法传给他
};

ostream& operator<<(ostream& cout,const Complex &c){
    cout<<"(" << c.r << "," << c.i << "i)" << endl;
    return cout;
}
```





#### ++重载

返回引用是为了一直对一个数据进行递增操作，必须要返回引用，不能返回值。

后置递增耗时（值传递）

前置递增返回引用，后置递增返回值，并且后置递增要加一个int**占位参数**

后置递增因为一直是对临时变量temp进行增加，返回，故无法使用(myint++)++

```c++
ostream& operator<<(ostream& cout,MyInteger const &myint);//注意这里要加上const或者去掉&
MyInteger operator++(int){
    MyInteger temp;
    m_Num++;
    return temp;
}
```

java里面不能++(++i)，c艹可以

但是java，c艹都不能(i++)++



##### 重载前缀运算符

不需要占位参数

##### 重载后缀运算符

要有一个占位参数

![image-20211028230839785](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211028230839785.png)





#### 赋值运算符重载

c++编译器至少给一个类添加4个函数

1. 默认构造函数（函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符operator=，对属性值进行拷贝。



new int ，返回的是int*.new出来的东西开辟在堆区，堆区的内容的特点：由程序员手动开辟，也需要由程序员手动释放。释放的时机在析构函数中



链式编程思想：对运算符重载时，要有返回值，不能是void



为什么要写赋值运算符重载？编译器提供的赋值运算符是浅拷贝的操作，当我们在堆区创建内容时，浅拷贝会直接复制所有的内存地址，这样在析构函数释放堆区内存时会造成堆区内存的重复释放，所以要重载赋值运算符。（注意返回值，为了可以使用连等，要返回被赋值类型的引用Person&）



#### 关系运算符的重载

可以让自定义对象可以进行比较操作。

#### ==运算符

注意这里要使用小括号，否则cout会报错

```c++
cout<< (p1==p2) <<endl;
```



#### 函数调用运算符重载()

由于重载后的使用方式特别像函数的调用，因此称为仿函数

仿函数非常灵活，没有固定的写法

必须要创建对象才能够调用仿函数

匿名对象特点：当前行执行完了立即被释放





## 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码   父类型的指针无法释放子类型的对象



虚析构和纯虚析构共性

- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

虚析构和纯虚析构区别

- 如果是纯虚析构，该类属于抽象类，无法实例化对象



父类指针在析构时候  不会调用子类中的析构函数，导致子类如果有堆区属性new，无法被释放，出现内存泄露

##### 解决方案：

在父类的析构函数前加上virtual，使其变为虚析构函数



父类析构函数不加virtual

![image-20211014012454558](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211014012454558.png)

父类析构函数加上virtual

![image-20211014012539211](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211014012539211.png)

利用虚析构可以解决  父类指针释放子类对象时不干净的问题

##### 语法

![image-20211014013139324](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211014013139324.png)



纯虚析构需要有说明，也要有实现。**一旦一个类有了纯虚析构，则该类一定是抽象类**。

纯虚函数可以只有说明，没有实现，类似接口。



若子类中开辟了新的new，位于堆区中的内存，此时父类中的虚构函数~Animal()无法释放在子类中开辟的堆区的内存，会造成内存泄漏，故对父类的析构函数使用虚析构或纯虚析构，来实现清除子类中开辟的堆区内存的目的。



##### 总结：

1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
3. 拥有纯虚析构函数的类也属于抽象类







# c++强制类型转换

在C++语言中新增了四个关键字static_cast、const_cast、reinterpret_cast和dynamic_cast。这四个关键字都是用于强制类型转换的。



![image-20211029134622201](C:\Users\s'c\AppData\Roaming\Typora\typora-user-images\image-20211029134622201.png)



## static_cast

> static_cast还可以转换对象，不仅仅可以转换指针
>
> 只有static_cast可以转换对象，用于把派生类对象转换成基类对象

static_cast可以将基类指针转换成派生类指针，也可以将派生类指针转换成基类指针。

在C++语言中static_cast用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。例如将整型数据转换为浮点型数据。

```c++
int a = 10;
int b = 3;
double result = static_cast<double>(a) / static_cast<double>(b);
```

在本例中同样是将整型变量a转换为双精度浮点型。采用static_cast进行强制数据类型转换时，将想要转换成的数据类型放到尖括号中，将待转换的变量或表达式放在元括号中，其格式可以概括为如下形式：  

**用法：static_cast <类型说明符> （变量或表达式）**

### 主要用法

1. 用于类层次结构中基类和派生类之间指针或引用的转换
      进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
      进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的
2. 用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证
3. 把空指针转换成目标类型的空指针
4. 把任何类型的表达式转换为void类型

  **注意**：static_cast不能转换掉expression的const、volitale或者__unaligned属性

**如果涉及到类的话，**static_cast只能在**有相互联系的类型中进行相互转换,**不一定包含虚函数。



## const_cast

在C语言中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改。

**而const_cast则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。**



### 主要用法

**用法：const_cast (expression)**

该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。
  常量指针被转化成非常量指针，并且仍然指向原来的对象；
  常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。



一个错误的例子：

```c++
const int a = 10;
const int * p = &a;
*p = 20;                  //compile error
int b = const_cast<int>(a);  //compile error
```

**在本例中出现了两个编译错误，第一个编译错误是\*p因为具有常量性，其值是不能被修改的；另一处错误是const_cast强制转换对象必须为指针或引用，而例3中为一个变量，这是不允许的！**



## dynamic_cast

基类指针可以转换成派生类指针，派生类指针也可以转换成基类指针，但是基类中必须要有虚函数。



**要根据运行时，看指针指向的到底是哪个类型的对象来进行判断，看转换能否成功。**



1. 其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。

2. 不能用于内置的基本数据类型的强制转换。

3. dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。

4. 使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。

​     B中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。

​    

​    这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于[虚函数表](http://baike.baidu.com/view/3750123.htm)的概念，详细可见）中，

​     只有定义了虚函数的类才有虚函数表。

 

5. 在类的转换时，在类层次间进行上行转换时，dynamic_cast和[static_cast](http://baike.baidu.com/view/1745207.htm)的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。

​    向上转换，即为子类指针转换成父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。

​    向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。

​     在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。





一个例子：

```c++
#include<iostream>
using namespace std;
 
class base
{
public :
    void m(){cout<<"m"<<endl;}
};
 
class derived : public base
{
public:
    void f(){cout<<"f"<<endl;}
};
 
int main()
{
    derived * p;
    //p = new base;
    p = static_cast<derived *>(new base);
    p->m();
    p->f();
    return 0;
}
```



本例中定义了两个类：base类和derived类，这两个类构成继承关系。在base类中定义了m函数，derived类中定义了f函数。在前面介绍多态时，我们一直是用基类指针指向派生类或基类对象，而本例则不同了。

本例主函数中定义的是一个派生类指针，当我们将其指向一个基类对象时，这是错误的，会导致编译错误。

但是通过强制类型转换我们可以将派生类指针指向一个基类对象，p = static_cast<derived *>(new base);语句实现的就是这样一个功能，这样的一种强制类型转换时合乎C++语法规定的，但是是非常不明智的，它会带来一定的危险。

在程序中p是一个派生类对象的指针，我们将其强制指向一个基类对象，首先通过p指针调用m函数，因为基类中包含有m函数，这一句没有问题，之后通过p指针调用f函数。一般来讲，因为p指针是一个派生类类型的指针，而派生类中拥有f函数，因此p->f();这一语句不会有问题，但是本例中p指针指向的却是基类的对象，而基类中并没有声明f函数，虽然p->f();这一语句虽然仍没有语法错误，但是它却产生了一个运行时的错误。换言之，p指针是派生类指针，这表明程序设计人员可以通过p指针调用派生类的成员函数f，但是在实际的程序设计过程中却误将p指针指向了一个基类对象，这就导致了一个运行期错误。

**产生这种运行期的错误原因在于static_cast强制类型转换时并不具有保证类型安全的功能，而C++提供的dynamic_cast却能解决这一问题，dynamic_cast可以在程序运行时检测类型转换是否类型安全。**

**当然dynamic_cast使用起来也是有条件的，它要求所转换的操作数必须包含多态类类型（即至少包含一个虚函数的类）。**



```c++
#include<iostream>
using namespace std;
 
class base
{
public :
    void m(){cout<<"m"<<endl;}
};
 
class derived : public base
{
public:
    void f(){cout<<"f"<<endl;}
};
 
int main()
{
    derived * p;
    //p = new base;
    //p = dynamic_cast<derived *>(new base);//error
    p->m();
    p->f();
    return 0;
}
```

在本例中利用dynamic_cast进行强制类型转换，但是因为base类中并不存在虚函数，因此p = dynamic_cast(new base);这一句会编译错误。

为了解决本例中的语法错误，我们可以将base类中的函数m声明为虚函数，virtual void m(){cout<<"m"<<endl;}

**dynamic_cast还要求<>内部所描述的目标类型必须为指针或引用。**



正确实例：

```c++
#include<iostream>
#include<cstring>
 
using namespace std;
 
class A
{
   public:
   virtual void f()
   {
       cout<<"hello"<<endl;
       };
};
 
  
 
class B:public A
{
    public:
    void f()
    {
        cout<<"hello2"<<endl;
        };
  
};
 
  
 
class C
{
  void pp()
  {
      return;
  }
};
 
  
 
int fun()
{
    return 1;
}
 
int main()
{
    A* a1=new B;//a1是A类型的指针指向一个B类型的对象
    A* a2=new A;//a2是A类型的指针指向一个A类型的对象
    B* b;
    C* c;
    b=dynamic_cast<B*>(a1);//结果为not null，向下转换成功，a1之前指向的就是B类型的对象，所以可以转换成B类型的指针。
    if(b==NULL)
    {
        cout<<"null"<<endl;
    }
 
    else
    {
        cout<<"not null"<<endl;
    }
 
    b=dynamic_cast<B*>(a2);//结果为null，向下转换失败
    if(b==NULL)
    {
        cout<<"null"<<endl;
    }
 
    else
    {
        cout<<"not null"<<endl;
    }
 
    c=dynamic_cast<C*>(a);//结果为null，向下转换失败
    if(c==NULL)
    {
        cout<<"null"<<endl;
    }
 
    else
    {
        cout<<"not null"<<endl;
    }
 
    delete(a);
    return 0;
}
```



# 模板

由类模板实例化得到的类叫模板类



### 类模板中的成员函数还可以是函数模板

```c++
#include <iostream>
using namespace std;
template <class T>
class A
{
public:
    template <class T2>
    void Func(T2 t) { cout << t; }  //成员函数模板
};
int main()
{
    A<int> a;
    a.Func('K');  //成员函数模板Func被实例化
    a.Func("hello");
    return 0;
}
```



### 模板测试

```c++
#include<iostream>
using namespace std;

template<typename T,int N>
class A{
private:
	T arr[N];
	
public:
	A(T x){
		for(int i = 0;i<N;i++){
			arr[i] = x+i;
		}
	}
	
	void show();
};

template<typename T,int N>
void A<T,N>::show(){
	for(int i = 0;i<N;i++){
		cout << "arr[" << i << "]" << arr[i] << endl;
	}
}


int main(){
	A<int,5> a(2);
	a.show();
	
	A<double,10> b(3.5);
	b.show();
	
}
```



### 模板参数的特殊化

有时，有些类型可能并不使用于该模板，需要对模板参数进行特殊化处理，这称为模板特化。

#### 函数模板的特化

对于函数模板，如果有多个模板参数，则必须提供所有参数的特例类型，不能部分特化。



- 在函数名后用<>括号括起具体类型

  ```c++
  template<>
  char* sum<char*>(char* a,char* b){...};
  ```

- 由编译器推导出具体类型，函数名为普通形式

  ```c++
  template<>
  char* sum(char* a,char* b){...};
  ```

  

#### 类模板的部分特化

对于类模板，允许部分特化，即部分限制模板的通用性

- 通用模板类

  ```c++
  template<class T1,class T2> class A{...};
  ```

- 部分特化的模板类

  ```c++
  template<class T1> class A<T1,int> {...};
  ```

- 若指定所有的类型，则<>内将为空

  ```c++
  template<> class A <int,int>{...};
  ```

注意：**类的后面加尖括号<>**